---
title: "Interface"
---

This section of the documentation focuses on the design of the interface
and how it is implemented as Python code.

::: callout-note
We use {{< var wip >}} to indicate parts of the design that are still a
work in progress, which will contain the function and class signatures.
Once the interface is implemented, indicated by {{< var done >}}, we
will remove the signatures from the documentation and point instead to
the reference documentation.
:::

## Inputs

This section describes the inputs accepted by `check-datapackage`.

-   **Descriptor:** This is a Python dictionary containing the
    properties of a Data Package or Data Resource. Allowed properties
    are defined in the [Data Package
    standard](https://datapackage.org/). A common use case is loading
    the descriptor from the `datapackage.json` file.
-   **Config:** A `Config` object can optionally be passed to
    `check-datapackage` with settings to modify the behaviour and output
    of the check mechanism.
-   **Error**: A boolean that controls whether the function errors out
    or returns a value if any issues are found.

## Outputs

For each failed check, `check-datapackage` flags the corresponding issue
in the descriptor. If all checks pass, an empty list is returned.

-   Default mode: The issues are returned as a list without stopping
    program execution.
-   Error mode: The issues result in errors that stop program execution.

## Functions

There are two main functions and two helper functions that we expose in
this package. Together, these functions could be combined to create a
command-line interface.

::: content-hidden
Potentially we could also have a function that lists what the checks are
or lists what fields can be excluded. Not sure if that works better as a
CLI or if it could be used some way as Python code. I didn't include it
for now though.
:::

### {{< var wip >}} `check()`

This is the main function of this package, which will check a Data
Package descriptor against the Data Package standard, as well as include
any custom exclusions or custom checks listed in the configuration.
Below is the signature of the interface:

``` python
def check(
    descriptor: dict,
    config: Config = Config(),
    error: bool = False
) -> list[Issue]:
    """Checks a Data Package descriptor against the Data Package standard.

    Args:
        descriptor: A Data Package descriptor as a Python dictionary.
        config: Configuration for the checks to be done. See the `Config`
            class for more details, especially about the default values.
        error: Whether to treat any issues found as errors. Defaults
            to False, meaning that issues will be returned as a list of `Issue`
            objects. Will internally run `explain()` on the Issues
            if set to `True`.

    Returns:
        list[Issue]: A list of `Issue` objects representing any issues found
            while checking the descriptor. If no issues are found, an empty list
            is returned.
    """
```

The `Config` class is described below. By default, `check()` does not
result in an error when issues are found, but errors can be triggered by
setting `error=True`. We don't want `check-datapackage` to trigger
errors by default because we want to allow users the flexibility to
decide when and how failed checks should be enforced or handled. The
output of this function is a list of `Issue` objects, which are
described below.

### {{< var wip >}} `explain()`

The output of `check()` is a list of `Issue` objects, which are
structured and machine-readable, but not very human-readable and
user-friendly. It's important to have this output to provide structured
information about the issues, but we also want to provide a way to
explain these issues in a more pleasant and ergonomic way.

``` python
def explain(issues: list[Issue]) -> list[str]:
    """Explain a list of issues in a user-friendly way.

    Args:
        issues: A list of `Issue` objects representing issues found while
            checking a Data Package descriptor.

    Returns:
        A list of user-friendly, human-readable messages
            explaining each issue.
    """
```

### {{< var wip >}} `read_json()`

This is a simple helper function to read the `datapackage.json` file
into a Python dictionary. See [`?read_json`](/docs/reference/read_json.qmd)
for more details.

### {{< var wip >}} `read_config()`

This is a simple helper function to read a configuration file into a
`Config` object for when we extend to having the configurations in a
file.

``` python
def read_config(path: Path) -> Config:
    """Reads a configuration file into a `Config` object.

    Args:
        path: The path to the configuration file.

    Returns:
        A `Config` object populated with the contents of the configuration
            file.
    """
```

## Classes

With all the configurations kept in one class, we can potentially store
the configuration in a file that can be read into the class, which would
be useful for a CLI interface.

### {{< var wip >}} `Config`

`Config` is a class that holds all the configurations for the `check()`
function.

See the help documentation with `help(Config)` for more details.

### {{< var wip >}} `Exclude`

A subitem of `Config` for expressing checks to ignore.

See the help documentation with `help(Exclude)` for more details.

#### {{< var wip >}} `Rule`

Expresses a custom check.

See the help documentation with `help(Rule)` for more details.

### {{< var wip >}} `Issue`

This class represents an issue that is found when checking a Data
Package, with the following interface:

``` python
@dataclass
class Issue:
    """An issue found while checking a Data Package descriptor

    One Issue object represents one failed check on one field within the descriptor.

    Attributes:
        location (string): A [JSON path](https://en.wikipedia.org/wiki/JSONPath)
            format, pointing to the field in the input object where the issue is located.
            For example, `"$.resources[2].name"`.
        message (string): A description of what exactly the issue is.
        type (string): The type of the check that failed.
            Used mostly for excluding specific types of issues.

    Methods:
        __str__(): Return a user-friendly, human-readable message of the issue, with more
            details than the `message` attribute and more context. Used when running
            `explain()` on the issues.
    """
    location: str
    message: str
    type: str

    def __str__(self) -> str:
        """Return a user-friendly, human-readable string representation of the issue."""
```

## Flow

This is the potential flow of using `check-datapackage`:

```{mermaid}
%%| label: fig-interface-flow
%%| fig-cap: "Flow of functions and classes when using `check-datapackage`."
%%| fig-alt: "A flowchart showing the flow of using `check-datapackage`, starting with reading the datapackage.json and .cdp.yaml files, then checking the descriptor with the config, and finally explaining any issues found."
flowchart TD
    descriptor_file[(datapackage.json)]
    read_json["read_json()"]
    descriptor[/"Descriptor<br>(dict)"/]

    config_file[(.cdp.yaml)]
    read_config["read_config()"]

    config[/Config/]
    rules[/Rules/]
    exclude[/Exclude/]
    check["check()"]
    issues[/"list[Issue]"/]

    explain["explain()"]
    messages[/messages/]

    descriptor_file --> read_json --> descriptor
    config_file --> read_config --> config
    rules & exclude --> config
    rules & exclude -.-> config_file

    descriptor & config --> check --> issues --> explain --> messages
```
