---
title: "Interface"
---

This section of the documentation focuses on the design of the interface
and how it is implemented as Python code.

::: callout-note
We use {{< var wip >}} to indicate parts of the design that are still a
work in progress, which will contain the function and class signatures.
Once the interface is implemented, indicated by {{< var done >}}, we
will remove the signatures from the documentation and point instead to
the reference documentation.
:::

## Inputs

This section describes the inputs accepted by `check-datapackage`.

-   **Descriptor:** This is a Python dictionary containing the
    properties of a Data Package or Data Resource. Allowed properties
    are defined in the [Data Package
    standard](https://datapackage.org/). A common use case is loading
    the descriptor from the `datapackage.json` file.
-   **Config:** A `Config` object can optionally be passed to
    `check-datapackage` with settings to modify the behaviour and output
    of the check mechanism.
-   **Error**: A boolean that controls whether the function errors out
    or returns a value if any issues are found.

## Outputs

For each failed check, `check-datapackage` flags the corresponding issue
in the descriptor. If all checks pass, an empty list is returned.

-   Default mode: The issues are returned as a list without stopping
    program execution.
-   Error mode: The issues result in errors that stop program execution.

## Functions

There are two main functions and two helper functions that we expose in
this package. Together, these functions could be combined to create a
command-line interface.

::: content-hidden
Potentially we could also have a function that lists what the checks are
or lists what fields can be excluded. Not sure if that works better as a
CLI or if it could be used some way as Python code. I didn't include it
for now though.
:::

### {{< var wip >}} `check()`

This is the main function of this package, which will check a Data
Package descriptor against the Data Package standard, as well as include
any custom exclusions or custom checks listed in the configuration.

See the help documentation with `help(check)` for more details.

The `Config` class is described below. By default, `check()` does not
result in an error when issues are found, but errors can be triggered by
setting `error=True`. We don't want `check-datapackage` to trigger
errors by default because we want to allow users the flexibility to
decide when and how failed checks should be enforced or handled. The
output of this function is a list of `Issue` objects, which are
described below.

### {{< var wip >}} `explain()`

The output of `check()` is a list of `Issue` objects, which are
structured and machine-readable, but not very human-readable and
user-friendly. It's important to have this output to provide structured
information about the issues, but we also want to provide a way to
explain these issues in a more pleasant and ergonomic way.

``` python
def explain(issues: list[Issue]) -> list[str]:
    """Explain a list of issues in a user-friendly way.

    Args:
        issues: A list of `Issue` objects representing issues found while
            checking a Data Package descriptor.

    Returns:
        A list of user-friendly, human-readable messages
            explaining each issue.
    """
```

### {{< var done >}} `read_json()`

This is a simple helper function to read the `datapackage.json` file
into a Python dictionary. See
[`help(read_json)`](/docs/reference/read_json.qmd) for more details.

### {{< var wip >}} `read_config()`

This is a simple helper function to read a configuration file into a
`Config` object for when we extend to having the configurations in a
file.

``` python
def read_config(path: Path) -> Config:
    """Reads a configuration file into a `Config` object.

    Args:
        path: The path to the configuration file.

    Returns:
        A `Config` object populated with the contents of the configuration
            file.
    """
```

## Classes

With all the configurations kept in one class, we can potentially store
the configuration in a file that can be read into the class, which would
be useful for a CLI interface.

### {{< var done >}} `Config`

`Config` is a class that holds all the configurations for the `check()`
function.

See the help documentation with `help(Config)` for more details.

### {{< var done >}} `Exclusion`

A sub-item of `Config` that expresses checks to exclude. This can be
useful if you want to exclude (or skip) certain checks from the Data
Package standard that are not relevant to your use case.

See the help documentation with `help(Exclusion)` for more details.

#### {{< var wip >}} `Extension`

This sub-item of `Config` defines extensions, i.e., additional checks that supplement those specified by the Data Package standard. It contains subitems that store
additional checks, such as `Required` and `CustomCheck`. This `Extension`
class might be expanded to include more types of extensions.

```` python
@dataclass
class Extension:
    """Extension to the standard checks.

    This contains additional checks to be made alongside the standard
    Data Package checks.

    Attributes:
        required: A list of `Required` objects defining properties to set as required.
        custom_check: A list of `CustomCheck` objects defining extra, custom checks to run alongside the standard
            checks.

    Examples:

        ```{python}
        import check_datapackage as cdp

        extensions = cdp.Extension(
            required=[
                cdp.Required(
                    jsonpath="$.description",
                    message="Data Packages must include a description."
                ),
                cdp.Required(
                    jsonpath="$.contributors[*].email",
                    message="All contributors must have an email address."
                )
            ],
            custom_check=[cdp.CustomCheck(
                type="only-mit",
                jsonpath="$.licenses[*].name",
                message="Data Packages may only be licensed under MIT.",
                check=lambda license_name: license_name == "mit",
            )]
        )
        # check(descriptor, config=cdp.Config(extensions=extensions))
        ```
    """
    required : Optional[list[Required]] = None
    custom_check : Optional[list[CustomCheck]] = None
````

Each extension class must implement it's own `apply()` method that takes
the `datapackage.json` properties `dict` as input and outputs an `Issue`
list that contains the issues found by that extension.

#### {{< var wip >}} `Required`

A sub-item of `Extension` that allows users to set specific properties
as required that are not required by the Data Package standard. See the
help documentation with `help(Required)` for more details.

#### {{< var done >}} `CustomCheck`

A sub-item of `Extension` that allows users to add an additional, custom check that `check-datapackage` will run alongside
the standard checks. See the help documentation with `help(CustomCheck)`
for more details.

### {{< var done >}} `Issue`

This class represents an issue that is found when checking a Data
Package.

See the help documentation with
[`help(Issue)`](/docs/reference/Issue.qmd) for more details.

## {{< var planned >}} Configuration file

When we develop the CLI, we'll use a config file to store the settings
contained within the `Config` class. This file will be named `.cdp.toml`
and will be located in the same directory as the `datapackage.json`
file. This is an example of what that file could look like:

``` toml
# The Data Package standard version to check against.
version = "v2"

# Whether to check properties that must *and should* be included.
strict = true

# Exclude all issues related to the "resources" property.
[[exclusions]]
jsonpath = "$.resources"

# Exclude all issues related to the "format" type in the schema.
[[exclusions]]
type = "format"

# Exclude issues that are both a "pattern" type and found in
# the "path" property of the "contributors" field.
[[exclusions]]
jsonpath = "$.contributors[*].path"
type = "pattern"

# Require that the "description" property is included in the Data Package.
[[extensions.required]]
jsonpath = "$.description"
message = "This Data Package needs to include a 'description' property."

# A custom check to ensure that all resource names are lowercase.
[[extensions.custom_check]]
jsonpath = "$.resources[*].name"
type = "name-lowercase"
message = "The value in the 'name' property of the 'resources' must be lowercase."
check = "lambda name: name.islower()"
```

## Flow

This is the potential flow of using `check-datapackage`:

```{mermaid}
%%| label: fig-interface-flow
%%| fig-cap: "Flow of functions and classes when using `check-datapackage`."
%%| fig-alt: "A flowchart showing the flow of using `check-datapackage`, starting with reading the datapackage.json and .cdp.toml files, then checking the descriptor with the config, and finally explaining any issues found."
flowchart TD
    descriptor_file[(datapackage.json)]
    read_json["read_json()"]
    descriptor[/"Descriptor<br>(dict)"/]

    config_file[(.cdp.toml)]
    read_config["read_config()"]

    config[/Config/]
    custom_check[/CustomCheck/]
    exclusion[/Exclusion/]
    check["check()"]
    issues[/"list[Issue]"/]

    explain["explain()"]
    messages[/messages/]

    descriptor_file --> read_json --> descriptor
    config_file --> read_config --> config
    custom_check & exclusion --> config
    custom_check & exclusion -.-> config_file

    descriptor & config --> check --> issues --> explain --> messages
```
