---
title: "Interface"
---

This section of the documentation focuses on the design of the interface
and how it is implemented as Python code.

::: callout-note
We use symbols to indicate parts of the design that are actively being worked on,
done, or planned (see table below). For
work that is planned or is in progress, we include the function
signatures and docstrings to clarify the design. Once the interface is
implemented (done), we will remove the signatures from the documentation
and point to the reference documentation instead. The symbols we use are
described in the table below.

| Status | Description |
|:-----------------------------:|:----------------------------------------|
| {{< var done >}} | Interface that has been implemented. |
| {{< var wip >}} | Interface that is currently being worked on. |
| {{< var planned >}} | Interface that is planned, but isn't being worked on currently. |

: A table showing the symbols used to indicate the status of interface
components, along with their descriptions.
:::

## Inputs

This section describes the inputs accepted by `check-datapackage`.

-   **Descriptor:** This is a Python dictionary containing the
    properties of a Data Package or Data Resource. Allowed properties
    are defined in the [Data Package
    standard](https://datapackage.org/). A common use case is loading
    the descriptor from the `datapackage.json` file.
-   **Config:** A `Config` object can optionally be passed to
    `check-datapackage` with settings to modify the behaviour and output
    of the check mechanism.
-   **Error**: A boolean that controls whether the function errors out
    or returns a value if any issues are found.

## Outputs

For each failed check, `check-datapackage` flags the corresponding issue
in the descriptor. If all checks pass, an empty list is returned.

-   Default mode: The issues are returned as a list without stopping
    program execution.
-   Error mode: The issues result in errors that stop program execution.

## Functions

There are two main functions and two helper functions that we expose in
this package. Together, these functions could be combined to create a
command-line interface.

::: content-hidden
Potentially we could also have a function that lists what the checks are
or lists what fields can be excluded. Not sure if that works better as a
CLI or if it could be used some way as Python code. I didn't include it
for now though.
:::

### {{< var wip >}} `check()`

This is the main function of this package, which will check a Data
Package descriptor against the Data Package standard, as well as include
any custom exclusions or custom checks listed in the configuration.

See the help documentation with `help(check)` for more details.

The `Config` class is described below. By default, `check()` does not
result in an error when issues are found, but errors can be triggered by
setting `error=True`. We don't want `check-datapackage` to trigger
errors by default because we want to allow users the flexibility to
decide when and how failed checks should be enforced or handled. The
output of this function is a list of `Issue` objects, which are
described below.

### {{< var planned >}} `explain()`

The output of `check()` is a list of `Issue` objects, which are
structured and machine-readable, but not very human-readable and
user-friendly. It's important to have this output to provide structured
information about the issues, but we also want to provide a way to
explain these issues in a more pleasant and ergonomic way.

``` python
def explain(issues: list[Issue]) -> list[str]:
    """Explain a list of issues in a user-friendly way.

    Args:
        issues: A list of `Issue` objects representing issues found while
            checking a Data Package descriptor.

    Returns:
        A list of user-friendly, human-readable messages
            explaining each issue.
    """
```

### {{< var done >}} `read_json()`

This is a simple helper function to read the `datapackage.json` file
into a Python dictionary. See
[`help(read_json)`](/docs/reference/read_json.qmd) for more details.

### {{< var planned >}} `read_config()`

This is a simple helper function to read a configuration file into a
`Config` object for when we extend to having the configurations in a
file.

``` python
def read_config(path: Path) -> Config:
    """Reads a configuration file into a `Config` object.

    Args:
        path: The path to the configuration file.

    Returns:
        A `Config` object populated with the contents of the configuration
            file.
    """
```

## Classes

With all the configurations kept in one class, we can potentially store
the configuration in a file that can be read into the class, which would
be useful for a CLI interface.

### {{< var done >}} `Config`

`Config` is a class that holds all the configurations for the `check()`
function.

See the help documentation with `help(Config)` for more details.

### {{< var done >}} `Exclusion`

A sub-item of `Config` that expresses checks to exclude. This can be
useful if you want to exclude (or skip) certain checks from the Data
Package standard that are not relevant to your use case.

See the help documentation with `help(Exclusion)` for more details.

#### {{< var done >}} `CustomCheck`

A sub-item of `Config`. Expresses a custom check.

See the help documentation with `help(CustomCheck)` for more details.

### {{< var done >}} `Issue`

This class represents an issue that is found when checking a Data
Package.

See the help documentation with
[`help(Issue)`](/docs/reference/Issue.qmd) for more details.

## Flow

This is the potential flow of using `check-datapackage`:

```{mermaid}
%%| label: fig-interface-flow
%%| fig-cap: "Flow of functions and classes when using `check-datapackage`."
%%| fig-alt: "A flowchart showing the flow of using `check-datapackage`, starting with reading the datapackage.json and .cdp.yaml files, then checking the descriptor with the config, and finally explaining any issues found."
flowchart TD
    descriptor_file[(datapackage.json)]
    read_json["read_json()"]
    descriptor[/"Descriptor<br>(dict)"/]

    config_file[(.cdp.yaml)]
    read_config["read_config()"]

    config[/Config/]
    custom_check[/CustomCheck/]
    exclusion[/Exclusion/]
    check["check()"]
    issues[/"list[Issue]"/]

    explain["explain()"]
    messages[/messages/]

    descriptor_file --> read_json --> descriptor
    config_file --> read_config --> config
    custom_check & exclusion --> config
    custom_check & exclusion -.-> config_file

    descriptor & config --> check --> issues --> explain --> messages
```
