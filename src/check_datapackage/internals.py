import re
from dataclasses import dataclass
from functools import reduce
from itertools import chain
from typing import (
    Any,
    Callable,
    Iterable,
    Iterator,
    Optional,
    TypeVar,
)

from jsonschema import Draft7Validator, FormatChecker, ValidationError

from check_datapackage.constants import (
    NAME_PATTERN,
    PACKAGE_RECOMMENDED_FIELDS,
    SEMVER_PATTERN,
)
from check_datapackage.exclude import _filter, _map
from check_datapackage.issue import Issue


def _add_package_recommendations(schema: dict[str, Any]) -> dict[str, Any]:
    """Add recommendations from the Data Package standard to the schema.

    Modifies the schema in place.

    Args:
        schema: The full Data Package schema.

    Returns:
        The updated Data Package schema.
    """
    schema["required"].extend(PACKAGE_RECOMMENDED_FIELDS.keys())
    schema["properties"]["name"]["pattern"] = NAME_PATTERN
    schema["properties"]["version"]["pattern"] = SEMVER_PATTERN
    schema["properties"]["contributors"]["items"]["required"] = ["title"]
    schema["properties"]["sources"]["items"]["required"] = ["title"]
    return schema


def _add_resource_recommendations(schema: dict[str, Any]) -> dict[str, Any]:
    """Add recommendations from the Data Resource standard to the schema.

    Modifies the schema in place.

    Args:
        schema: The full Data Package schema.

    Returns:
        The updated Data Package schema.
    """
    schema["properties"]["resources"]["items"]["properties"]["name"]["pattern"] = (
        NAME_PATTERN
    )
    return schema


def _check_object_against_json_schema(
    json_object: dict[str, Any], schema: dict[str, Any]
) -> list[Issue]:
    """Checks that `json_object` matches the given JSON schema.

    Structural, type and format constraints are all checked. All schema violations are
    collected before issues are returned.

    Args:
        json_object: The JSON object to check.
        schema: The JSON schema to check against.

    Returns:
        A list of issues. An empty list, if no issues are found.

    Raises:
        jsonschema.exceptions.SchemaError: If the given schema is invalid.
    """
    Draft7Validator.check_schema(schema)
    validator = Draft7Validator(schema, format_checker=FormatChecker())
    return _validation_errors_to_issues(validator.iter_errors(json_object))


@dataclass
class SchemaError:
    """A simpler representation of `ValidationError` for easier processing.

    Attributes:
        message (str): The error message generated by `jsonschema`.
        type (str): The type of the error.
        schema_path (str): The path to the violated rule in the JSON schema.
            Path components are separated by '/'.
        jsonpath (str): The JSON path to the field that violates the rule.
        parent (Optional[SchemaError]): The error group the error belongs to, if any.
    """

    message: str
    type: str
    schema_path: str
    jsonpath: str
    parent: Optional["SchemaError"] = None


def _validation_errors_to_issues(
    validation_errors: Iterator[ValidationError],
) -> list[Issue]:
    """Transforms `jsonschema.ValidationError`s to more compact `Issue`s.

    Args:
        validation_errors: The `jsonschema.ValidationError`s to transform.

    Returns:
        A list of `Issue`s.
    """
    schema_errors = _flat_map(validation_errors, _validation_error_to_schema_errors)
    grouped_errors = _filter(
        schema_errors, lambda error: error.type in {"oneOf", "anyOf"}
    )
    schema_errors = reduce(_handle_grouped_error, grouped_errors, schema_errors)

    issues = _map(schema_errors, _create_issue)
    return sorted(set(issues))


def _handle_grouped_error(
    schema_errors: list[SchemaError], parent_error: SchemaError
) -> list[SchemaError]:
    """Handle grouped schema errors that need special treatment.

    Args:
        parent_error: The parent error of a group.
        schema_errors: All remaining schema errors.

    Returns:
        The schema errors after processing.
    """
    # Handle issues at $.resources[x]

    if parent_error.schema_path.endswith("resources/items/oneOf"):
        schema_errors = _handle_S_resources_x(parent_error, schema_errors)

    # Handle issues at $.resources[x].path
    if parent_error.schema_path.endswith("resources/items/properties/path/oneOf"):
        schema_errors = _handle_S_resources_x_path(parent_error, schema_errors)

    return schema_errors


def _handle_S_resources_x(
    parent_error: SchemaError,
    schema_errors: list[SchemaError],
) -> list[SchemaError]:
    """Do not flag missing `path` and `data` separately."""
    errors_in_group = _filter(schema_errors, lambda error: error.parent == parent_error)
    path_or_data_required_errors = _filter(
        errors_in_group, _path_or_data_required_error
    )

    # If path and data are both missing, add a more informative error
    if path_or_data_required_errors:
        schema_errors.remove(parent_error)
        schema_errors.append(
            SchemaError(
                message=(
                    "This resource has no `path` or `data` field. "
                    "One of them must be provided."
                ),
                type="required",
                jsonpath=parent_error.jsonpath,
                schema_path=parent_error.schema_path,
            )
        )

    # Remove all original required errors on $.resources[x].path and $.resources[x].data
    return _filter(
        schema_errors, lambda error: error not in path_or_data_required_errors
    )


def _handle_S_resources_x_path(
    parent_error: SchemaError,
    schema_errors: list[SchemaError],
) -> list[SchemaError]:
    """Only flag errors for the relevant type.

    If `path` is a string, flag errors for the string-based schema.
    If `path` is an array, flag errors for the array-based schema.
    """
    errors_in_group = _filter(schema_errors, lambda error: error.parent == parent_error)
    type_errors = _filter(errors_in_group, _is_path_type_error)
    only_type_errors = len(errors_in_group) == len(type_errors)

    if type_errors:
        schema_errors.remove(parent_error)

    # If the only error is that $.resources[x].path is of the wrong type,
    # add a a more informative error
    if only_type_errors:
        schema_errors.append(
            SchemaError(
                message="The `path` property must be either a string or an array.",
                type="type",
                jsonpath=type_errors[0].jsonpath,
                schema_path=type_errors[0].schema_path,
            )
        )

    # Remove all original type errors on $.resources[x].path
    return _filter(schema_errors, lambda error: error not in type_errors)


In = TypeVar("In")
Out = TypeVar("Out")


def _next(items: Iterable[In], condition: Callable[[In], bool]) -> Optional[In]:
    """Returns the first item from the iterable that fulfills the condition.

    If no item fulfills the condition, returns None.
    """
    return next(filter(condition, items), None)


def _flat_map(items: Iterable[In], fn: Callable[[In], Iterable[Out]]) -> list[Out]:
    """Maps and flattens the items by one level."""
    return list(chain.from_iterable(map(fn, items)))


def _get_full_json_path_from_error(error: ValidationError) -> str:
    """Returns the full `json_path` to the error.

    For 'required' errors, the field name is extracted from the error message.

    Args:
        error: The error to get the full `json_path` for.

    Returns:
        The full `json_path` of the error.
    """
    if str(error.validator) == "required":
        match = re.search("'(.*)' is a required property", error.message)
        if match:
            return f"{error.json_path}.{match.group(1)}"
    return error.json_path


def _validation_error_to_schema_errors(error: ValidationError) -> list[SchemaError]:
    current = [_create_schema_error(error)]
    if not error.context:
        return current

    return current + _flat_map(error.context, _validation_error_to_schema_errors)


def _create_schema_error(error: ValidationError) -> SchemaError:
    return SchemaError(
        message=error.message,
        type=str(error.validator),
        jsonpath=_get_full_json_path_from_error(error),
        schema_path="/".join(_map(error.absolute_schema_path, str)),
        parent=_create_schema_error(error.parent) if error.parent else None,  # type: ignore[arg-type]
    )


def _path_or_data_required_error(error: SchemaError) -> bool:
    return error.jsonpath.endswith(("path", "data")) and error.type == "required"


def _is_path_type_error(error: SchemaError) -> bool:
    return error.type == "type" and error.jsonpath.endswith("path")


def _create_issue(error: SchemaError) -> Issue:
    return Issue(
        message=error.message,
        location=error.jsonpath,
        type=error.type,
    )
